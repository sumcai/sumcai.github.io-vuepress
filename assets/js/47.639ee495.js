(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{612:function(e,a,t){"use strict";t.r(a);var n=t(20),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"opengl-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#opengl-api"}},[e._v("#")]),e._v(" OpenGL API")]),e._v(" "),t("p",[e._v("汇集了常用的api函数，以及示例用法")]),e._v(" "),t("h2",{attrs:{id:"glbindbuffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glbindbuffer"}},[e._v("#")]),e._v(" glBindBuffer")]),e._v(" "),t("p",[e._v("把缓冲绑定到对应的目标上，以下面代码为例，绑定"),t("code",[e._v("GL_ARRAY_BUFFER")]),e._v("， 从这一刻起，使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("unsigned int VBO;\nglGenBuffers(1, &VBO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);  \n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"glbindtexture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glbindtexture"}},[e._v("#")]),e._v(" glBindTexture")]),e._v(" "),t("p",[e._v("将一个命名的纹理id绑定到一个纹理目标上")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("glBindTexture(GL_TEXTURE_2D, texture);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("纹理目标类型：GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE 或者 GL_TEXTURE_2D_MULTISAMPLE_ARRAY")]),e._v(" "),t("h2",{attrs:{id:"glbindvertexarray"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glbindvertexarray"}},[e._v("#")]),e._v(" glBindVertexArray")]),e._v(" "),t("p",[e._v("绑定一个顶点数组对象VAO，随后的顶点属性调用都会储存在这个VAO中。")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("GLuint VAO;\nglGenVertexArrays(1, &VAO);\nglBindVertexArray(VAO);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"glbufferdata"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glbufferdata"}},[e._v("#")]),e._v(" glBufferData")]),e._v(" "),t("p",[e._v("把用户定义的数据复制到当前绑定的缓冲目标。")]),e._v(" "),t("p",[e._v("GL_ARRAY_BUFFER： 目标缓冲的类型为顶点缓冲对象")]),e._v(" "),t("p",[e._v("sizeof(vertices)：传输数据的大小(以字节为单位)")]),e._v(" "),t("p",[e._v("vertices：发送的实际数据。")]),e._v(" "),t("p",[e._v("第四个参数指定了显卡如何管理给定的数据，有三种形式：")]),e._v(" "),t("ul",[t("li",[e._v("GL_STATIC_DRAW ：数据不会或几乎不会改变。")]),e._v(" "),t("li",[e._v("GL_DYNAMIC_DRAW：数据会被改变很多。")]),e._v(" "),t("li",[e._v("GL_STREAM_DRAW ：数据每次绘制时都会改变。")])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("h2",{attrs:{id:"gldrawarrays"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gldrawarrays"}},[e._v("#")]),e._v(" glDrawArrays")]),e._v(" "),t("p",[t("code",[e._v("void glDrawArrays(GLenum mode, GLint first, GLsizei count)")])]),e._v(" "),t("p",[e._v("绘制图元。")]),e._v(" "),t("ul",[t("li",[e._v("mode：需要渲染的图元类型，包括 GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN ，GL_TRIANGLES。")]),e._v(" "),t("li",[e._v("first：从数组缓存中的哪一位开始绘制，一般为0.")]),e._v(" "),t("li",[e._v("count：数组中顶点的数量.")])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const GLfloat points[] = {\n    -1.0f, -1.0f, 0.0f,     // 左下角\n    1.0f, -1.0f, 0.0f,      // 右下角\n    0.0f, 0.0f, 0.0f,       // 中间点\n};\n// 方式一\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, points);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglDisableVertexAttribArray(0);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br")])]),t("h2",{attrs:{id:"gldrawelements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gldrawelements"}},[e._v("#")]),e._v(" glDrawElements")]),e._v(" "),t("p",[t("code",[e._v("void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)")])]),e._v(" "),t("p",[e._v("根据顶点索引绘图")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("mode：绘制类型，可以是GL_POLYGON、GL_TRIANGLES、GL_TRIANGLE_STRIP、GL_LINE_STRIP等。")])]),e._v(" "),t("li",[t("p",[e._v("count：组合几何图形的元素的个数，一般是点的个数。")])]),e._v(" "),t("li",[t("p",[e._v("type：indeices数组的数据类型，既然是索引，一般是整型的。")])]),e._v(" "),t("li",[t("p",[e._v("indices：索引数组")])])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const GLfloat g_vertex_buffer_data[] = {\n\t\t-1.0f, -1.0f, 0.0f,     // 左下角\n\t\t1.0f, -1.0f, 0.0f,      // 右下角\n\t\t0.0f, 0.0f, 0.0f        // 中间点\n};\nunsigned int indices[] = {0, 1, 2};\n\n// VAO、VBO、EBO的数据\nGLuint VAO;\nGLuint VBO;\nGLuint EBO;\nglGenVertexArrays(1, &VAO);\nglBindVertexArray(VAO);\n\nglGenBuffers(1, &VBO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW);\n\nglGenBuffers(1, &EBO);\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\nglEnableVertexAttribArray(0);\n\nglDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br"),t("span",{staticClass:"line-number"},[e._v("22")]),t("br"),t("span",{staticClass:"line-number"},[e._v("23")]),t("br"),t("span",{staticClass:"line-number"},[e._v("24")]),t("br"),t("span",{staticClass:"line-number"},[e._v("25")]),t("br"),t("span",{staticClass:"line-number"},[e._v("26")]),t("br")])]),t("h2",{attrs:{id:"glenablevertexattribarray"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glenablevertexattribarray"}},[e._v("#")]),e._v(" glEnableVertexAttribArray")]),e._v(" "),t("p",[e._v("启用某位置的顶点属性，通常与glVertexAttribPointer 第一个参数以及glsl中的layout(location=x)配合使用")]),e._v(" "),t("h2",{attrs:{id:"glgenbuffers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glgenbuffers"}},[e._v("#")]),e._v(" glGenBuffers")]),e._v(" "),t("p",[e._v("生成一个VBO对象 , VBO保存生成对象ID")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("unsigned int VBO; \nglGenBuffers(1, &VBO); \n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("h2",{attrs:{id:"glgentextures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glgentextures"}},[e._v("#")]),e._v(" glGenTextures")]),e._v(" "),t("p",[t("code",[e._v("void glGenTextures(GLsizei n,GLuint * textures)")])]),e._v(" "),t("p",[e._v("产生ｎ个纹理ID存储在"),t("code",[e._v("textures")]),e._v("数组中")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("GLuint texture;\nglGenTextures(1, &texture);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("h2",{attrs:{id:"glgenvertexarrays"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glgenvertexarrays"}},[e._v("#")]),e._v(" glGenVertexArrays")]),e._v(" "),t("p",[e._v("生成一个顶点数组对象VAO")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("GLuint VAO;\nglGenVertexArrays(1, &VAO);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("h2",{attrs:{id:"glteximage2d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glteximage2d"}},[e._v("#")]),e._v(" glTexImage2D")]),e._v(" "),t("p",[t("code",[e._v("void glTexImage2D(GLenum target, GLint level, GLenum internalformat,GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels)")])]),e._v(" "),t("p",[e._v("指定二维纹理和立方体纹理 。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("target：指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z，或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。")])]),e._v(" "),t("li",[t("p",[e._v("level：指定详细程度编号。级别0是基本图像级别。级别n是第n个缩略图缩小图像。")])]),e._v(" "),t("li",[t("p",[e._v("internalformat：指定纹理的内部格式。必须是下列符号常量之一：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA。")])]),e._v(" "),t("li",[t("p",[e._v("width：指定纹理图像的宽度。所有实现都支持宽度至少为64 texels的2D纹理图像和宽度至少为16 texels的立方体贴图纹理图像。")])]),e._v(" "),t("li",[t("p",[e._v("height：指定纹理图像的高度所有实现都支持至少64像素高的2D纹理图像和至少16像素高的立方体贴图纹理图像。")])]),e._v(" "),t("li",[t("p",[e._v("border：指定边框的宽度。必须为0。")])]),e._v(" "),t("li",[t("p",[e._v("format：指定纹理数据的格式。必须匹配internalformat。下面的符号值被接受：GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA。")])]),e._v(" "),t("li",[t("p",[e._v("type：指定纹理数据的数据类型。下面的符号值被接受：GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1。")])]),e._v(" "),t("li",[t("p",[e._v("data：指定一个指向内存中图像数据的指针。")])])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('int width, height, channels;\nstbi_set_flip_vertically_on_load(true);\nunsigned char* data = stbi_load("data/img/test.jpg", &width, &height, &channels, 0);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("h2",{attrs:{id:"gltexparameteri"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gltexparameteri"}},[e._v("#")]),e._v(" glTexParameteri")]),e._v(" "),t("p",[e._v("设置纹理的属性")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 环绕方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n// 过滤方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("h2",{attrs:{id:"glvertexattribpointer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glvertexattribpointer"}},[e._v("#")]),e._v(" glVertexAttribPointer")]),e._v(" "),t("p",[t("code",[e._v("void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer)")])]),e._v(" "),t("p",[e._v("OpenGL解析顶点数据（应用到逐个顶点属性上）的规则，")]),e._v(" "),t("ul",[t("li",[e._v("第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用"),t("code",[e._v("layout(location = 0)")]),e._v("定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为"),t("code",[e._v("0")]),e._v("。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入"),t("code",[e._v("0")]),e._v("。")]),e._v(" "),t("li",[e._v("第二个参数指定顶点属性的大小。顶点属性是一个"),t("code",[e._v("vec3")]),e._v("，它由3个值组成，所以大小是3。")]),e._v(" "),t("li",[e._v("第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中"),t("code",[e._v("vec*")]),e._v("都是由浮点数值组成的)。")]),e._v(" "),t("li",[e._v("下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。")]),e._v(" "),t("li",[e._v("第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个"),t("code",[e._v("float")]),e._v("之后，我们把步长设置为"),t("code",[e._v("3 * sizeof(float)")]),e._v("。也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。")]),e._v(" "),t("li",[e._v("最后一个参数的类型是"),t("code",[e._v("void*")]),e._v("，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。")])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("h2",{attrs:{id:"glgetuniformlocation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#glgetuniformlocation"}},[e._v("#")]),e._v(" glGetUniformLocation")]),e._v(" "),t("p",[e._v("获取shader中"),t("code",[e._v("uniform")]),e._v("变量的位置")]),e._v(" "),t("h2",{attrs:{id:"gluniform"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gluniform"}},[e._v("#")]),e._v(" glUniform*")]),e._v(" "),t("p",[e._v("为shader设置"),t("code",[e._v("uniform")]),e._v("变量的值")]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("void glUniform1f(GLint location, GLfloat v0);\nvoid glUniform2f(GLint location,  GLfloat v0, GLfloat v1);\nvoid glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);\nvoid glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);\nvoid glUniform1i(GLint location, GLint v0);\nvoid glUniform2i(GLint location,GLint v0,GLint v1);\nvoid glUniform3i(GLint location,GLint v0,GLint v1,GLint v2);\nvoid glUniform4i(GLint location,GLint v0,GLint v1,GLint v2,GLint v3);\n\nvoid glUniform1fv(GLint location,GLsizei count,const GLfloat *value);\nvoid glUniform2fv(GLint location,GLsizei count,const GLfloat *value);\nvoid glUniform3fv(GLint location,GLsizei count,const GLfloat *value);\nvoid glUniform4fv(GLint location,GLsizei count,const GLfloat *value);\nvoid glUniform1iv(GLint location,GLsizei count,const GLint *value);\nvoid glUniform2iv(GLint location,GLsizei count,const GLint *value);\nvoid glUniform3iv(GLint location, GLsizei count, const GLint *value);\nvoid glUniform4iv(GLint location, GLsizei count, const GLint *value);\n\nvoid glUniformMatrix2fv(GLint location,GLsizei countM,GLboolean transpose,const GLfloat *valueM);\nvoid glUniformMatrix3fv(GLint location,GLsizei countM,GLboolean transpose,const GLfloat *valueM);\nvoid glUniformMatrix4fv(GLint location,GLsizei countM,GLboolean transpose, const GLfloat *valueM);\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br")])]),t("ul",[t("li",[t("p",[e._v("location：指定要修改的统一变量的位置。")])]),e._v(" "),t("li",[t("p",[e._v("v0，v1，v2，v3：指定要用于指定统一变量的新值。")])]),e._v(" "),t("li",[t("p",[e._v("count：指定要修改的元素数。 如果目标统一变量不是数组，则此值应为1;如果是数组，则应为1或更大。")])]),e._v(" "),t("li",[t("p",[e._v("value：指定指向将用于更新指定统一变量的count值数组的指针。")])]),e._v(" "),t("li",[t("p",[e._v("countM：指定要修改的矩阵数。 如果目标统一变量不是矩阵数组，则该值应为1;如果是矩阵数组，则应为1或更大。")])]),e._v(" "),t("li",[t("p",[e._v("transpose：指定在将值加载到统一变量时是否转置矩阵。 必须是GL_FALSE。")])]),e._v(" "),t("li",[t("p",[e._v("valueM：指定指向将用于更新指定统一变量的countM值数组的指针。")])])]),e._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('glm::mat4 mvp = projection * view * model;\nGLuint mvpId = glGetUniformLocation(programID, "MVP");\nglUniformMatrix4fv(mvpId, 1, GL_FALSE, &mvp[0][0]);\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])])])}),[],!1,null,null,null);a.default=s.exports}}]);